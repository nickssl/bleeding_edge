<!-- This file was generated by mk_html_help.pro -->
<html>
 
<head>
<TITLE>projects/SPP/fields/util</TITLE>
</head>
 
<body>
<P>
This page was created by the IDL library routine 
<CODE>mk_html_help2</CODE>.
<br>
<P>
<STRONG>Last modified: </STRONG>Thu Dec 22 18:16:33 2022.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>Directory Listing of Routines</H1></A>
<UL>
<H1>projects/SPP/fields/util</H1>
<LI><A HREF="#READ_XML8">READ_XML8</A>
<br>READ an XML document file into IDL (Interactive Data Language, ITT).
<LI><A HREF="#[1]">[1]</A>
<LI><A HREF="#SPP_FLD_STATUSPLOT">SPP_FLD_STATUSPLOT</A>
<br>Procedure used to display status bars on a TPLOT.
<LI><A HREF="#STR_CLEAN">STR_CLEAN</A>
<br>To remove all unprintable characters from the given string
<LI><A HREF="#XML2IDL8">XML2IDL8</A>
<br>Translate a DOM (Document Object Model) object (read in
<br>
</UL><P>
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="READ_XML8">
<H2>READ_XML8</H2></A>
<A HREF="#SPP_FLD_STATUSPLOT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	READ_XML8	

 PURPOSE:
	READ an XML document file into IDL (Interactive Data Language, ITT).  
	This function is specifically for IDL version 8 and above because
	it uses both OrderedHashes and Lists which were introduced in version 8.
	Output is an IDL Ordered Hash with Lists for repeating elements.
	This function reads the file and parses the XML document into a DOM
	(Document Object Model) object or IDLffXMLDOMDocument.
	It passes oDoc to XML2IDL8 which walks through the nodes creating the hash.  

 CATEGORY:
	Datafile handling; XML

 CALLING SEQUENCE:
	Result = READ_XML8(filename, [ outFile=outFile, validation = validation ])

 INPUTS:
	filename  - name of XML file to read (string)

 OUTPUTS:
	Result is a hash of hashes or lists that represents the XML file.  
	One can access the various nodes
	by indexing into it, like this:           
	IDL&gt; print, hash[rootname,elname,childname,'_text']
          
	If there are siblings with the same name, then they are pulled together
	in a list which is indexed by number:

	IDL&gt; i++
	IDL&gt; print, hash[rootname,repeatedname,i,childname,'_text'];	
          
	To see what the childnames are for element elnameN:
	
	IDL&gt; print, hash[rootname,elname,...,elnameN].Keys()
	
 KEYWORDS:
	outFile - If set to a filename, will save pretty printout to that file

	validation - Turns on validation of xml file
			The Schema or DTD need to on local disk.
	
 PROCEDURES USED:
	XML2IDL8
	
 PACKAGE LOCATION:
	http://www.astro.umd.edu/~eshaya/PDS/pds4readxml.tar

 MODIFICATION HISTORY:
	Written by Ed Shaya / U. of Maryland [Nov 5, 2013]
	Removed path variable.  Now filename should contain path if needed. ES/Dec 3, 2013.
	Switched to ordered hash so elements stay in order.  Now using
	XML2IDL8.pro.  ES/Oct 10, 2014.
	Removed use of prettyhash (toscreen) since IDL now does this
	natively when you enter the hash name ES/Oct 10, 2014
</PRE><P>
<STRONG>(See <A href="util/read_xml8.pro">projects/SPP/fields/util/read_xml8.pro</A>)</STRONG><P>
<HR>
 
<A NAME="SPP_FLD_STATUSPLOT">
<H2>SPP_FLD_STATUSPLOT</H2></A>
<A HREF="#READ_XML8">[Previous Routine]</A>
<A HREF="#STR_CLEAN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
 	spp_fld_statusplot

 PROCEDURE:
 	spp_fld_statusplot, x, y, overplot = overplot, limits = lim, data = data

 INPUT:
 	x: array of x values.
	  y: array of y strings.

 PURPOSE:
 	Procedure used to display status bars on a TPLOT.
   SPP_FLD_STATUSPLOT uses the SPECPLOT routine to plot a TPLOT variable
   that can take on one of several discrete STRING values.

 KEYWORDS:
	DATA:		A structure containing the elements 'x' and 'y'.
	LIMITS:		The limits structure for the TPLOT variable.
	OVERPLOT:	If set, data is plotted over current plot.
	STAT_VALS:	An array of strings containing possible
			values for the 'y' variable.  If STAT_VALS is unset,
			STATUSPLOT plots status bars for each unique
			string contained in the 'y' variable.

 EXAMPLE:	
	If 'Channel' is a TPLOT variable with possible values of
	'Ch1', 'Ch2', and 'Off', then the following commands
	will set up statusplot.
	
	options, 'Channel', 'tplot_routine', 'statusplot'
	options, 'Channel', 'stat_vals', ['Off', 'Ch1', 'Ch2']
	tplot, 'Channel'
		
 MOD HISTORY:
 	Original version, based on the STRPLOT procedure,
	created 27 May 2009 by Marc Pulupa.  
</PRE><P>
<STRONG>(See <A href="util/spp_fld_statusplot.pro">projects/SPP/fields/util/spp_fld_statusplot.pro</A>)</STRONG><P>
<HR>
 
<A NAME="STR_CLEAN">
<H2>STR_CLEAN</H2></A>
<A HREF="#SPP_FLD_STATUSPLOT">[Previous Routine]</A>
<A HREF="#XML2IDL8">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME: 
	STR_CLEAN
     
 PURPOSE: 
	To remove all unprintable characters from the given string
 
 CALLING SEQUENCE: 
	Result = STR_CLEAN (text, [/SPACE])
 
 INPUTS:
	Text: Scalar string of characters to be cleaned

 OUTPUTS:
	Result: Scalar string of characters removed of all unprintable characters

 OPTIONAL INPUTS:
	SPACE: removes all unprintable characters including all space chars.

 EXAMPLE:
	To remove all unprintable chars except space
	IDL&gt; word = STR_CLEAN ('the [tab]file is [lf][cr]')
	IDL&gt; print, word
	the file is

	To remove all unprintable chars including space
	IDL&gt; word = STR_CLEAN ('the [tab]file is [lf][cr]',/SPACE)
	IDL&gt; print, word
	thefileis

 PACKAGE LOCATION:
	http://www.astro.umd.edu/~eshaya/PDS/pds4readxml.tar

 MODIFICATION HISTORY:
	Written by Puneet Khetarpal, January 15, 2003

</PRE><P>
<STRONG>(See <A href="util/str_clean.pro">projects/SPP/fields/util/str_clean.pro</A>)</STRONG><P>
<HR>
 
<A NAME="XML2IDL8">
<H2>XML2IDL8</H2></A>
<A HREF="#STR_CLEAN">[Previous Routine]</A>
<A HREF="#[1]">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	XML2IDL8

 PURPOSE:
	Translate a DOM (Document Object Model) object (read in
	from an XML file with read_xml.pro) into either an IDL hash
	by recursion through the document tree.	The '8' in the name
	indicates this version is for IDL version 8.3 and above
	as it uses ordered hashes and lists which were introduced to IDL in
	version 8.3.  For the IDL hash, XML element names become
	key names in the hash.  Elements with non-null text get a
	'_text' key.  Comments are attached to parent elements with
	'_comment' key.  Attributes are similarly treated with the
	attribute name as the key.  They can be distinguished from
	element text by the lack of a '_text' key.
	
	All non-essential whitespace is removed.  IDL variable names are allowed
	to have only the special characters '_','$', and '!', so all other
	special characters are converted to '_'.
	
 CATEGORY:
	Datafile handling; XML

 CALLING SEQUENCE:
	myhash = XML2IDL8(oChild,nodeName=childName,nodeValue=childValue) 
       
 INPUTS:
	oNode -  DOM Document object (IDLffXMLDOMDocument) or top DOM Node 
		(IDLffXMLDOMNode) to convert to string array

 OUTPUTS:
	Returns a hash of hashes or lists that represents the XML file.  One can access the various nodes
	by indexing into it, like this:
          
	IDL&gt; print, hash[rootname,elName,childname,'_text']
          
	If there are siblings with the same name, then they are pulled together in a list which
	is indexed by number:
          
	IDL&gt; i++
	IDL&gt; print, hash[rootname,repeatedname,i,childname,'_text']
 
 KEYWORDS:
	nodeName - returns nodeName of oNode

	nodeVAlue - returns nodeValue of oNode
	hash - If there are children elements, this returns a hash 
	holding information on them

 PROCEDURE:
	A number of input parameters and keywords are used internally only.  
	They are used when the program walks through the document tree by 
	recursively calling itself.  These are: paramArr, nodeName, 
	and nodeValue 
	
 MODIFICATION HISTORY:
	Written by Ed Shaya / U. of Maryland [Nov 5, 2013]
	Removed empty _text except for true empty elements ES [Dec 2013]
</PRE><P>
<STRONG>(See <A href="util/xml2idl8.pro">projects/SPP/fields/util/xml2idl8.pro</A>)</STRONG><P>
<HR>
 
<A NAME="[1]">
<H2>[1]</H2></A>
<A HREF="#XML2IDL8">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>

 NAME:

   SPP_FLD_RFS_FLOAT

 DESCRIPTION:

   The 64 bit values of onboard RFS spectra are compressed to
   16 bit floating point values for telemetry.  The specifications
   of the bits for exponent, mantissa, and sign (cross spectra only)
   as well as example calculations are in the documents

   SPF_FSW_908_RFS_Calcs.xlsx
   SPF_FSW_912_RFS_HFR_Verification.xlsx

   This program is an IDL version of the calculation which decompresses
   those values.

   Input can be integers (long or long longs also OK), a string
   with an integer value, a four character hex string (e.g. '2D73x'),
   or a sixteen bit binary string (e.g. '0010110101110011b').

   Input can be an array, but the input array has to all be the
   same type (e.g., all integers or all hex strings).

   Input must be within the range of 0 to 2^16 - 1.  Out of range
   inputs will return a value of -1.0D30.

   Output is an array of the same dimensions as the input,
   containing the double precision uncompressed RFS quantities.

   Typical compression errors are less than 0.1%.

 KEYWORDS:

   CROSS: Use the signed cross spectra calculation instead of the
     unsigned auto spectra calculation.

   VERBOSE: Show detailed output of the input in various formats,
     the sign, exponent, and mantissa.

   BIGINTS: If this keyword is set to a variable, then a list of
     IDL BigInteger values is returned.  The calculated values for the
     RFS floating point calculation can overflow a 64 bit integer, so if
     the exact (non-double-precision) values are necessary, they can
     be returned with this keyword.

     BigIntegers don't work with array-based operations, so use of this
     keyword will make the program run much more slowly.

     This keyword also only currently works with scalar or vector inputs.
     
   ZERO_FIX: Correct an error in which can assign a value of zero to 
     telemetered compressed data. See details in comments below.

 EXAMPLES:

   A single value:

   IDL&gt; print, spp_fld_rfs_float(11635, /verbose)
   IDL&gt; print, spp_fld_rfs_float('0x2D73')

   Both should return an exponent of 11, a mantissa of 371, and
   a return of 1428480.

   Calculate all valid inputs for auto and cross product compressed values:

   IDL&gt; rfs_comp = lindgen(2l^16)
   IDL&gt; rfs_auto_decomp = spp_fld_rfs_float(rfs_comp, bigints = rfs_auto_big)
   IDL&gt; rfs_cros_decomp = spp_fld_rfs_float(rfs_comp, bigints = rfs_cros_big, /cross)

   IDL&gt; rfs_auto_decomp = spp_fld_rfs_float(rfs_comp)
   IDL&gt; rfs_cros_decomp = spp_fld_rfs_float(rfs_comp, /cross)

   The calculations should produce the same result, but the ones without
   the bigints will be much faster.

   Plot results:

   IDL&gt; plot, rfs_comp, rfs_auto_decomp, /ylog, yrange = [1.,1.e25], psym = 3
   IDL&gt; oplot, rfs_comp, rfs_cros_decomp, psym = 3, col = 2
   IDL&gt; oplot, rfs_comp, -rfs_cros_decomp, psym = 3, col = 6

   The plots should show the floating point variables which correspond
   to all valid 16 bit inputs.

 HISTORY:

   Initial version Spring 2016 by MPP
   Commented and cleaned up August 2016 by MPP

 $LastChangedBy: pulupalap $
 $LastChangedDate: 2022-08-26 13:32:56 -0700 (Fri, 26 Aug 2022) $
 $LastChangedRevision: 31047 $
 $URL: svn+ssh://thmsvn@ambrosia.ssl.berkeley.edu/repos/spdsoft/trunk/projects/SPP/fields/util/spp_fld_rfs_float.pro $

</PRE><P>
<STRONG>(See <A href="util/spp_fld_rfs_float.pro">projects/SPP/fields/util/spp_fld_rfs_float.pro</A>)</STRONG><P>
<HR>
 
